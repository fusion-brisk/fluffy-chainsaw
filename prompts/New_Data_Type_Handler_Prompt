# Контекст: Добавление нового типа данных в EProductSnippet

## Проект

**EProductSnippet (Contentify)** — Figma-плагин для автозаполнения макетов данными из HTML поисковой выдачи Яндекса.

**Версия:** 2.4.0  
**Стек:** TypeScript → Rollup + Babel → ES5 (IIFE)

---

## Архитектура

### Поток данных

```
HTML/MHTML файл
    ↓
snippet-parser.ts (парсинг DOM → CSVRow[])
    ↓
data-assignment.ts (маппинг rows → containers)
    ↓
snippet-processor.ts (основной цикл)
    ↓
handlers/registry.ts (19 handlers)
    ↓
image-handlers.ts + text-handlers.ts
    ↓
Figma layers обновлены
```

### Ключевые типы

```typescript
// CSVRow — строка данных (поля начинаются с #)
interface CSVRow {
  '#OrganicTitle'?: string;
  '#OrganicPrice'?: string;
  '#ShopName'?: string;
  '#FaviconImage'?: string;
  '#imageType'?: string;        // Тип картинки: EThumbGroup, EProductMedia и т.д.
  '#SnippetType'?: string;      // Тип сниппета: EShopItem, ESnippet и т.д.
  // ... другие поля
}

// HandlerContext — контекст для handler'а
interface HandlerContext {
  container: BaseNode;          // Figma контейнер (EShopItem, ESnippet...)
  containerKey: string;         // ID контейнера
  row: CSVRow;                  // Данные для заполнения
}

// HandlerResult — результат выполнения
interface HandlerResult {
  handlerName: string;
  success: boolean;
  duration: number;
  error?: string;
}
```

---

## Система Handlers

### Регистрация (registry.ts)

```typescript
// Приоритеты выполнения
enum HandlerPriority {
  CRITICAL = 0,    // Сброс, базовая настройка
  VARIANTS = 10,   // Variant properties
  VISIBILITY = 20, // Показ/скрытие слоёв
  TEXT = 30,       // Текстовые поля
  FALLBACK = 40    // Финальная обработка
}

// Регистрация handler'а
handlerRegistry.register({
  name: 'MyNewHandler',
  priority: HandlerPriority.VARIANTS,
  containers: ['EShopItem', 'ESnippet'],  // Для каких контейнеров
  execute: async (ctx: HandlerContext): Promise<HandlerResult> => {
    // Логика обработки
    return { handlerName: 'MyNewHandler', success: true, duration: 0 };
  }
});
```

### Существующие handlers

| Файл | Handlers | Описание |
|------|----------|----------|
| `snippet-handlers.ts` | imageTypeHandler, ESnippetHandler, EOfferItemHandler | Типы изображений, ESnippet логика |
| `price-handlers.ts` | EPriceGroupHandler, EPriceHandler, FintechHandler | Цены, скидки, финтех |
| `button-handlers.ts` | EButtonHandler, CheckoutButtonHandler | Кнопки "Купить", "В корзину" |
| `label-handlers.ts` | ELabelGroupHandler, RatingHandler, BarometerHandler | Рейтинг, барометр цен |
| `delivery-handlers.ts` | DeliveryHandler, BNPLHandler, CrossborderHandler | Доставка, рассрочка |

---

## Парсинг данных (snippet-parser.ts)

### Структура extractRowData()

```typescript
export function extractRowData(
  container: Element,
  doc: Document,
  cssCache: CSSCache,
  isCatalogPage: boolean
): CSVRow {
  const row: CSVRow = {};
  
  // Извлечение данных из DOM
  row['#OrganicTitle'] = extractTitle(container);
  row['#OrganicPrice'] = extractPrice(container);
  // ... другие поля
  
  // Определение типа изображения
  row['#imageType'] = detectImageType(container);
  
  return row;
}
```

### Добавление нового поля

1. Найти DOM-элемент с данными
2. Добавить извлечение в `extractRowData()`
3. Создать handler для обработки в Figma

---

## Figma API (для handlers)

### Поиск узлов (используй кэш!)

```typescript
import { 
  findCachedNodeByName, 
  findCachedTextLayer,
  findCachedInstance,
  hasContainerCache 
} from '../utils/container-cache';

// Быстрый поиск (O(1) если кэш есть)
if (hasContainerCache(ctx.containerKey)) {
  const textNode = findCachedTextLayer(ctx.containerKey, '#PriceLabelText');
  const instance = findCachedInstance(ctx.containerKey, 'EPriceGroup');
}

// Fallback (медленный рекурсивный)
import { findTextLayerByName, findInstanceByName } from '../utils/node-search';
const textNode = findTextLayerByName(ctx.container, '#PriceLabelText');
```

### Изменение Variant Properties

```typescript
function setVariantProperty(instance: InstanceNode, propName: string, value: string): boolean {
  try {
    const props = instance.componentProperties;
    if (props && propName in props) {
      instance.setProperties({ [propName]: value });
      return true;
    }
  } catch (e) {
    Logger.warn(`Не удалось установить ${propName}=${value}`);
  }
  return false;
}
```

### Изменение текста

```typescript
import { safeSetTextNode } from '../utils/node-search';

const textNode = findCachedTextLayer(containerId, '#MyTextField');
if (textNode) {
  await safeSetTextNode(textNode, 'Новый текст');
}
```

### Скрытие/показ узлов

```typescript
const node = findCachedNodeByName(containerId, 'OptionalElement');
if (node && 'visible' in node) {
  (node as SceneNode).visible = false;
}
```

---

## Шаблон нового Handler'а

```typescript
// src/handlers/my-new-handler.ts

import { Logger } from '../logger';
import { HandlerContext, HandlerResult, HandlerPriority } from './types';
import { handlerRegistry } from './registry';
import { findCachedInstance, findCachedTextLayer, hasContainerCache } from '../utils/container-cache';
import { findInstanceByName, findTextLayerByName, safeSetTextNode } from '../utils/node-search';

/**
 * Handler для обработки MyNewField
 */
async function executeMyNewHandler(ctx: HandlerContext): Promise<HandlerResult> {
  const startTime = Date.now();
  const { container, containerKey, row } = ctx;
  
  // 1. Проверка наличия данных
  const myFieldValue = row['#MyNewField'];
  if (!myFieldValue) {
    return { handlerName: 'MyNewHandler', success: true, duration: Date.now() - startTime };
  }
  
  // 2. Поиск целевого компонента (сначала кэш, потом fallback)
  let targetInstance: InstanceNode | null = null;
  if (hasContainerCache(containerKey)) {
    targetInstance = findCachedInstance(containerKey, 'MyComponent') || null;
  }
  if (!targetInstance) {
    targetInstance = findInstanceByName(container, 'MyComponent');
  }
  
  if (!targetInstance) {
    Logger.debug(`[MyNewHandler] Компонент MyComponent не найден в ${containerKey}`);
    return { handlerName: 'MyNewHandler', success: true, duration: Date.now() - startTime };
  }
  
  // 3. Применение данных
  try {
    // Пример: установка variant property
    if ('componentProperties' in targetInstance) {
      const props = targetInstance.componentProperties;
      if (props && 'State' in props) {
        targetInstance.setProperties({ 'State': myFieldValue });
        Logger.debug(`[MyNewHandler] State=${myFieldValue}`);
      }
    }
    
    // Пример: установка текста внутри инстанса
    const textNode = findTextLayerByName(targetInstance, '#LabelText');
    if (textNode) {
      await safeSetTextNode(textNode, myFieldValue);
    }
    
  } catch (error) {
    const errMsg = error instanceof Error ? error.message : String(error);
    Logger.error(`[MyNewHandler] Ошибка:`, error);
    return { handlerName: 'MyNewHandler', success: false, duration: Date.now() - startTime, error: errMsg };
  }
  
  return { handlerName: 'MyNewHandler', success: true, duration: Date.now() - startTime };
}

// Регистрация
handlerRegistry.register({
  name: 'MyNewHandler',
  priority: HandlerPriority.VARIANTS,
  containers: ['EShopItem', 'ESnippet', 'EProductSnippet2'],
  execute: executeMyNewHandler
});

export { executeMyNewHandler };
```

---

## Чеклист добавления нового типа данных

### 1. Парсинг (snippet-parser.ts)
- [ ] Найти DOM-селектор для данных
- [ ] Добавить извлечение в `extractRowData()`
- [ ] Добавить поле в возвращаемый `CSVRow`

### 2. Handler (handlers/*.ts)
- [ ] Создать функцию `executeXxxHandler()`
- [ ] Зарегистрировать в `handlerRegistry`
- [ ] Экспортировать из `component-handlers.ts`

### 3. Типы (если нужно)
- [ ] Добавить поле в `CSVRow` (types/index.ts)
- [ ] Добавить в `IMAGE_FIELDS` если это изображение

### 4. Тестирование
- [ ] Проверить парсинг HTML
- [ ] Проверить применение к Figma компонентам
- [ ] Проверить логи

---

## Важные ограничения

1. **ES5 target** — никаких `async/await` на верхнем уровне, только внутри функций
2. **Нет Node.js API** — только браузерное API и Figma Plugin API
3. **Кэш контейнеров** — всегда используй `hasContainerCache()` + `findCached*()` для скорости
4. **Логирование** — используй `Logger.info/debug/warn/error`

---

## Файлы для изучения

| Файл | Зачем |
|------|-------|
| `src/handlers/registry.ts` | Как работает система handlers |
| `src/handlers/snippet-handlers.ts` | Примеры handlers |
| `src/utils/snippet-parser.ts` | Парсинг DOM → CSVRow |
| `src/utils/container-cache.ts` | Кэш структуры контейнеров |
| `src/config.ts` | Конфигурация, типы контейнеров |

---

## Пример диалога

**User:** Нужно добавить обработку поля "Гарантия" (#Warranty) из DOM-элемента с классом `.warranty-badge`

**AI:**
1. Найду селектор в snippet-parser.ts
2. Добавлю извлечение `row['#Warranty'] = ...`
3. Создам `WarrantyHandler` для установки текста/variant в Figma
4. Зарегистрирую в registry
5. Протестирую сборку


