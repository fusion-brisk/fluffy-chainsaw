# Аудит системы парсинга HTML — Contentify Plugin

## Контекст проекта
Figma-плагин "Contentify" для автозаполнения макетов данными из HTML (Яндекс выдача).
Парсим HTML/MHTML файлы, извлекаем данные из сниппетов товаров и применяем к Figma компонентам.

---

## Архитектура системы парсинга HTML

### Основные файлы:

| Файл | Роль |
|------|------|
| `src/utils/snippet-parser.ts` | **ГЛАВНЫЙ** — `parseYandexSearchResults()`, `extractRowData()` |
| `src/utils/dom-utils.ts` | Поиск контейнеров, `findSnippetContainers()`, `extractProductURL()` |
| `src/parsing-rules.ts` | Правила парсинга (CSS селекторы для полей) — `DEFAULT_PARSING_RULES` |
| `config/parsing-rules.json` | JSON-версия для удалённого обновления |
| `src/utils/price-extractor.ts` | `extractPrices()` — извлечение цен |
| `src/utils/favicon-extractor.ts` | Извлечение фавиконок (спрайты, inline, CSS) |
| `src/utils/dom-cache.ts` | DOM кэш (Phase 5 optimization) |
| `src/utils/css-cache.ts` | CSS кэш (Phase 4 optimization) |
| `src/utils/regex.ts` | Скомпилированные regex паттерны |
| `src/utils/mhtml-parser.ts` | Парсер MHTML файлов |
| `src/component-handlers.ts` | Применение данных к Figma компонентам |
| `src/config.ts` | Конфигурация контейнеров и компонентов |

---

## Типы сниппетов (контейнеры)

```
Organic_withOfferInfo  — органик с ценой/магазином
EProductSnippet2       — товарные сниппеты (новый формат)
EShopItem              — карточки магазинов Яндекс.Маркета
ProductTile-Item       — карточки в плитке товаров
```

Определяются в `dom-utils.ts` → `findSnippetContainers()`:
```typescript
const combinedSelector = [
  '[class*="Organic_withOfferInfo"]',
  '[class*="EProductSnippet2"]',
  '[class*="EShopItem"]',
  '.ProductTile-Item',
  '[class*="ProductTile-Item"]'
].join(', ');
```

---

## Извлекаемые поля (CSVRow)

### Базовые:
- `#OrganicTitle`, `#ShopName`, `#OrganicHost`, `#OrganicPath`, `#ProductURL`

### Изображения:
- `#OrganicImage`, `#ThumbImage`, `#FaviconImage`

### Цены:
- `#OrganicPrice`, `#OldPrice`, `#Currency`, `#DiscountPercent`, `#discount`

### Рейтинги:
- `#ShopRating`, `#ReviewsNumber`, `#ProductRating`

### Компоненты (Variant Properties для Figma):
- `#EPriceGroup_Discount` — флаг наличия скидки ('true'/'false')
- `#EPriceGroup_OldPrice` — флаг наличия старой цены ('true'/'false')
- `#EPriceGroup_Fintech` — флаг наличия Fintech ('true'/'false')
- `#EPrice_View` — view для EPrice ('special'/'default')
- `#LabelDiscount_View` — view для скидки ('outlineSpecial'/'outlinePrimary')
- `#Fintech_Type` — тип Fintech ('Split'/'Pay')
- `#Fintech_View` — view Fintech ('Extra Short'/'Short'/'Long'/'Extra Long')
- `#ELabelGroup_Barometer` — флаг барометра цены
- `#EPriceBarometer_View` — view барометра ('below-market'/'in-market'/'above-market')
- `#EDeliveryGroup`, `#EDeliveryGroup-Item-N`, `#EDeliveryGroup-Count`
- `#EMarketCheckoutLabel`, `#OfficialShop`

---

## КРИТИЧЕСКИ ВАЖНАЯ ЛОГИКА

### 1. Обработка цен — `extractPrices()` в `price-extractor.ts`

```typescript
// Ищем ТОЛЬКО .EPrice-Value (не родительские контейнеры!)
// НЕ используем [class*="EPriceGroup-Price"] — захватывает лишний текст
const priceElements = container.querySelectorAll('.EPrice-Value');

// Разделяем на текущие и старые цены по классу EPrice_view_old
// Проверяем до 5 уровней родителей на наличие 'view_old'
if (parentClasses.includes('view_old') || parentClasses.includes('EPrice_view_old')) {
  isOldPrice = true;
}

// Старая цена определяется ТОЛЬКО по классу, не по эвристике 10%
// (раньше был баг: скидка 2% не захватывалась из-за порога 10%)
```

### 2. Обработка рейтинга — `extractRowData()` в `snippet-parser.ts`

```typescript
// ВАЖНО: Используем ТОЧНЫЙ класс .ELabelRating, не подстроку!
// Потому что LabelDiscount имеет класс ELabelRating_size_3xs (подстрока совпадает!)
// но НЕ имеет точного класса ELabelRating

// Селекторы:
'.ELabelRating:not(.LabelDiscount)',
'.ELabelRating:not([class*="LabelDiscount"])',
'.ELabelRating'  // НЕ используем [class*="ELabelRating"]

// Дополнительная проверка после нахождения:
if (labelRating) {
  const labelClasses = labelRating.className || '';
  if (labelClasses.includes('LabelDiscount')) {
    labelRating = null; // Это скидка, не рейтинг!
  }
}
```

### 3. Обработка скидки (без EPriceGroup-Pair)

```typescript
// ВАЖНО: НЕ используем [class*="LabelDiscount"] — захватывает EPriceGroup_withLabelDiscount!
const discountLabel = container.querySelector(
  '.LabelDiscount .Label-Content, .LabelDiscount.Label .Label-Content'
);

// Проверяем что текст содержит %
if (discText.includes('%')) {
  const match = discText.match(DISCOUNT_PERCENT_REGEX);
  if (match) {
    row['#DiscountPercent'] = match[1];
    row['#EPriceGroup_Discount'] = 'true';
    row['#discount'] = `–${match[1]}%`;
  }
}
```

### 4. Логика view для EPrice и LabelDiscount

```typescript
// ПОСЛЕ извлечения Fintech:
const hasDiscount = row['#EPriceGroup_Discount'] === 'true' || row['#DiscountPercent'] || row['#discount'];
const hasFintech = row['#EPriceGroup_Fintech'] === 'true';

if (hasDiscount && !hasFintech) {
  // Скидка БЕЗ Fintech → обычные стили
  if (!row['#LabelDiscount_View']) {
    row['#LabelDiscount_View'] = 'outlinePrimary';
  }
  if (!row['#EPrice_View']) {
    row['#EPrice_View'] = 'default';
  }
} else if (!hasDiscount) {
  // БЕЗ скидки → сброс на default
  row['#EPrice_View'] = 'default';
}

// С Fintech:
// - EPrice_view_special → #EPrice_View = 'special'
// - Label_view_outlineSpecial → #LabelDiscount_View = 'outlineSpecial'
// - Префикс "Вам" добавляется к скидке
```

### 5. Применение view в Figma — `handleEPriceGroup()` в `component-handlers.ts`

```typescript
// ВАЖНО: Используем #EPrice_View если установлен (учитывает Fintech)
const explicitView = row['#EPrice_View'];
let viewVariants: string[];

if (explicitView === 'special') {
  // С Fintech — зелёная цена
  viewVariants = ['special', 'Special'];
} else if (explicitView === 'default' || !hasDiscount) {
  // Без Fintech или без скидки — обычная цена
  viewVariants = ['default', 'Default'];
} else {
  // Fallback
  viewVariants = ['default', 'Default'];
}
```

---

## ИСПРАВЛЕННЫЕ БАГИ (история)

### Баг 1: Rating захватывал LabelDiscount
- **Проблема**: `[class*="ELabelRating"]` захватывал элементы с `ELabelRating_size_3xs` (скидка)
- **Решение**: Использовать точный класс `.ELabelRating`, добавить проверку на `LabelDiscount`

### Баг 2: OldPrice не извлекался при скидке <10%
- **Проблема**: Эвристика `price * 1.1` не захватывала маленькие скидки
- **Решение**: Определять старую цену по классу `EPrice_view_old`, не по разнице

### Баг 3: Цены дублировались (74990 → 7499074990)
- **Проблема**: Селектор `[class*="EPriceGroup-Price"]` захватывал родительский контейнер
- **Решение**: Использовать только `.EPrice-Value`

### Баг 4: LabelDiscount находил EPriceGroup_withLabelDiscount
- **Проблема**: `[class*="LabelDiscount"]` захватывал родительский EPriceGroup
- **Решение**: Использовать точный класс `.LabelDiscount`

### Баг 5: Цены показывались зелёными без Fintech
- **Проблема**: `hasDiscount = true` → `viewVariants = ['special']`
- **Решение**: Использовать `#EPrice_View` из парсера, который учитывает Fintech

---

## ПАТТЕРНЫ view В HTML

| Fintech | LabelDiscount view | EPrice view | Результат |
|---------|-------------------|-------------|-----------|
| true | outlineSpecial | special | Зелёная цена, "Вам –X%" |
| false | outlinePrimary | (нет) | Обычная цена, "–X%" |
| false | (нет) | (нет) | Обычная цена без скидки |

---

## ЗАДАЧИ ДЛЯ АУДИТА

1. **Проверить селекторы** — все ли используют точные классы где нужно?
2. **Проверить fallback логику** — нет ли скрытых путей где данные теряются?
3. **Проверить порядок извлечения** — зависимости между полями корректны?
4. **Проверить типы сниппетов** — все ли обрабатываются одинаково?
5. **Проверить edge cases** — что если нет цены? нет магазина? нет изображения?
6. **Проверить производительность** — DOM/CSS кэши работают эффективно?
7. **Проверить дублирование кода** — есть ли повторяющаяся логика?

---

## ТЕСТОВЫЕ ДАННЫЕ

Пример HTML: `examples/iphone17.html` — поисковая выдача iPhone 17
Содержит разные типы сниппетов: с Fintech, без Fintech, со скидками, без скидок.

---

## КОМАНДЫ ДЛЯ ПРОВЕРКИ

```bash
# Сборка
npm run build

# Анализ HTML (Python скрипты в корне)
python3 analyze_iphone17.py
python3 analyze_eproductsnippet2.py

# Проверка результата в Figma через MCP
# http://127.0.0.1:3845/mcp
```

---

## НАЧАТЬ АУДИТ

1. Прочитать `src/utils/snippet-parser.ts` целиком
2. Прочитать `src/utils/price-extractor.ts`
3. Прочитать `src/component-handlers.ts` (особенно handleEPriceGroup)
4. Проверить `src/parsing-rules.ts` на актуальность селекторов
5. Сравнить с `config/parsing-rules.json`
6. Запустить плагин и проверить результат на `examples/iphone17.html`

