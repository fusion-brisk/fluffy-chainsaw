# Задача: Кэширование структуры свойств компонентов

## Контекст
Figma-плагин Contentify заполняет макеты данными из CSV/HTML. При обработке 79 контейнеров плагин тратит время на перебор вариантов имён свойств для каждого инстанса.

## Текущая проблема
В `property-utils.ts` → `processVariantProperty()` при попытке установить свойство (например, `Old Price=true`) плагин последовательно перебирает варианты:
```
"Old Price" → не найдено
"OldPrice" → не найдено  
"Old_Price" → не найдено
"old price" → не найдено
"oldprice" → не найдено
```

Это происходит для КАЖДОГО из 79 контейнеров, хотя все инстансы `EPriceGroup` имеют одинаковую структуру свойств.

### Лог-доказательство проблемы
```
⚠️ Свойства не найдены в компонентах:
   "Old Price" в EPriceGroup: 79×
   "BUTTON" в EProductSnippet: 47×
   "View" в LabelDiscount: 35×
```

## Желаемое решение: Component Properties Cache

### Архитектура

```typescript
// Кэш структуры свойств компонентов
interface ComponentPropertiesCache {
  // Ключ: componentId главного компонента инстанса
  [componentId: string]: ComponentPropertyInfo;
}

interface ComponentPropertyInfo {
  // Карта: нормализованное имя → реальное имя свойства
  propertyNames: Map<string, string>;  // "oldprice" → "Old Price#14715:9"
  
  // Карта: имя свойства → метаданные
  properties: Map<string, PropertyMetadata>;
}

interface PropertyMetadata {
  key: string;           // Полный ключ "Old Price#14715:9"
  simpleName: string;    // Простое имя "Old Price"
  type: 'VARIANT' | 'BOOLEAN' | 'TEXT' | 'INSTANCE_SWAP';
  options?: string[];    // Для VARIANT: доступные значения
  defaultValue?: string | boolean;
}
```

### Алгоритм

1. **При первой встрече инстанса определённого компонента:**
   ```typescript
   function getOrBuildPropertyCache(instance: InstanceNode): ComponentPropertyInfo {
     const componentId = instance.mainComponent?.id;
     if (!componentId) return null;
     
     // Проверяем кэш
     if (cache.has(componentId)) {
       return cache.get(componentId);
     }
     
     // Строим кэш из componentProperties
     const info = buildPropertyInfo(instance);
     cache.set(componentId, info);
     return info;
   }
   ```

2. **Построение кэша (один раз на компонент):**
   ```typescript
   function buildPropertyInfo(instance: InstanceNode): ComponentPropertyInfo {
     const propertyNames = new Map<string, string>();
     const properties = new Map<string, PropertyMetadata>();
     
     for (const [key, prop] of Object.entries(instance.componentProperties)) {
       const simpleName = key.split('#')[0];
       const normalized = simpleName.toLowerCase().replace(/[\s_-]/g, '');
       
       // Регистрируем все варианты нормализации
       propertyNames.set(normalized, key);
       propertyNames.set(simpleName.toLowerCase(), key);
       propertyNames.set(simpleName, key);
       
       properties.set(key, {
         key,
         simpleName,
         type: prop.type,
         options: prop.options,
         defaultValue: prop.value
       });
     }
     
     return { propertyNames, properties };
   }
   ```

3. **Использование кэша:**
   ```typescript
   function findPropertyKey(instance: InstanceNode, requestedName: string): string | null {
     const cache = getOrBuildPropertyCache(instance);
     if (!cache) return null;
     
     // Нормализуем запрошенное имя
     const normalized = requestedName.toLowerCase().replace(/[\s_-]/g, '');
     
     // Мгновенный lookup вместо перебора
     return cache.propertyNames.get(normalized) 
         || cache.propertyNames.get(requestedName.toLowerCase())
         || cache.propertyNames.get(requestedName)
         || null;
   }
   ```

### Ключевые оптимизации

1. **O(1) lookup вместо O(n) перебора** — нормализованные имена в Map
2. **Один анализ на компонент** — все инстансы EPriceGroup используют один кэш
3. **Предсказуемые ошибки** — если свойства нет в кэше, сразу знаем без перебора
4. **Валидация значений** — для VARIANT проверяем options до setProperties

### Файлы для изменения

1. **Новый файл `src/utils/component-cache.ts`:**
   - `ComponentPropertiesCache` — хранилище
   - `getOrBuildPropertyCache()` — получение/построение кэша
   - `findPropertyKey()` — поиск свойства по любому варианту имени
   - `resetComponentCache()` — сброс перед batch
   - `logComponentCacheStats()` — статистика использования

2. **`src/property-utils.ts`:**
   - Заменить перебор вариантов на `findPropertyKey()`
   - Использовать кэш для валидации VARIANT options
   - Убрать дублирующиеся проверки

3. **`src/plugin/snippet-processor.ts`:**
   - Добавить `resetComponentCache()` перед обработкой

### Пример до/после

**До (текущий код):**
```typescript
// Пробуем разные варианты имени
if (propertyName in instance.componentProperties) {
  foundPropertyKey = propertyName;
} else {
  for (const propKey in instance.componentProperties) {
    if (propKey.startsWith(propertyName)) { ... }
  }
  // Ещё один цикл с нормализацией...
}
```

**После (с кэшем):**
```typescript
const propertyKey = findPropertyKey(instance, propertyName);
if (!propertyKey) {
  trackMissingProperty(instance.name, propertyName);
  return false;
}
// Сразу используем найденный ключ
```

### Метрики успеха

1. **Время Handlers batch** — ожидаемое сокращение с 172s до ~100-120s
2. **Количество операций** — вместо 79×5 проверок = 395 → 79×1 = 79
3. **Консистентность** — одинаковый результат для всех инстансов одного компонента

### Ограничения

- Кэш валиден только в рамках одного batch (сбрасывается перед каждой обработкой)
- Не кэшируем инстансы без mainComponent (редкий случай)
- ES5-совместимость: Map заменить на object если нужно

## Дополнительно

После реализации кэша можно оптимизировать:
1. **Предзагрузку** — анализировать все уникальные компоненты до handlers batch
2. **Диагностику** — показывать какие свойства реально есть vs какие ожидаются
3. **Автоисправление** — предлагать правильное имя свойства при ошибке

## Связанные файлы

- `src/property-utils.ts` — текущая логика поиска свойств (628 строк)
- `src/plugin/snippet-processor.ts` — основной цикл обработки
- `src/handlers/` — handlers используют processVariantProperty()




