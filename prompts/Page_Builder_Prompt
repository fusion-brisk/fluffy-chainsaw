## Контекст проекта

Figma-плагин **Contentify** — автозаполнение макетов данными из HTML/CSV.

**Текущая архитектура:**
- `src/code.ts` → `dist/code.js` (ES5, IIFE)
- `src/ui.tsx` → `dist/ui.html` (React)
- Парсинг HTML: `src/utils/snippet-parser.ts` (1700+ строк)
- Обработчики: `src/handlers/` (snippet, price, delivery, button, label)
- Компоненты: ESnippet, EOfferItem, EShopItem, EProductSnippet2, Organic

**Ключевые технологии:**
- Figma Plugin API (ES5 target, без Node.js)
- TypeScript → Babel → Rollup
- postMessage для UI ↔ code.js

**Что уже работает:**
- Парсинг HTML в структурированные данные (CSVRow)
- Поиск контейнеров (сниппетов) в Figma
- Применение данных к существующим инстансам
- Component properties: `withButton`, `withMeta`, `withData`, `withDelivery`, `withFintech`, etc.
- Обработка изображений, текстов, вариантов

---

## Новая задача: Page Builder

### Сценарий для пользователя:
1. Сохранить HTML-файл с результатами поиска (SERP)
2. Открыть плагин в Figma, закинуть HTML-файл
3. **Плагин создаёт структуру страницы:**
   - Анализирует HTML-структуру (вложенность, порядок элементов)
   - Создаёт Auto Layout фреймы, повторяющие вёрстку
   - Внутри фреймов размещает инстансы из подключённой дизайн-библиотеки
   - Заполняет инстансы данными из того же HTML
4. Результат: готовый макет для дальнейшей работы в Figma

### Технические требования:

**Парсинг структуры HTML:**
```typescript
// Пример структуры SERP
// <div class="serp-list">
//   <div class="serp-item" data-cid="0">EProductSnippet</div>
//   <div class="serp-item" data-cid="1">EOfferItem</div>
//   <div class="organic organic_type_text">Organic</div>
// </div>
```

**Создание компонентов в Figma:**
```typescript
// 1. Найти компонент в библиотеке по имени
const component = await figma.importComponentByKeyAsync(componentKey);

// 2. Создать инстанс
const instance = component.createInstance();

// 3. Добавить в Auto Layout frame
parentFrame.appendChild(instance);

// 4. Применить данные
await applyDataToInstance(instance, rowData);
```

**Маппинг HTML → Figma компоненты:**
```typescript
const COMPONENT_MAP = {
  'EProductSnippet2': 'COMPONENT_KEY_FROM_LIBRARY',
  'EOfferItem': 'COMPONENT_KEY_FROM_LIBRARY',
  'EShopItem': 'COMPONENT_KEY_FROM_LIBRARY',
  'ESnippet': 'COMPONENT_KEY_FROM_LIBRARY',
  'Organic': 'COMPONENT_KEY_FROM_LIBRARY',
  // ...
};
```

**Auto Layout структура:**
```typescript
// Создание контейнера страницы
const pageFrame = figma.createFrame();
pageFrame.name = 'SERP Page';
pageFrame.layoutMode = 'VERTICAL';
pageFrame.primaryAxisSizingMode = 'AUTO';
pageFrame.counterAxisSizingMode = 'FIXED';
pageFrame.itemSpacing = 16;
```

### Вопросы для проработки:

1. **Как получить component keys из библиотеки?**
   - `figma.teamLibrary.getAvailableLibraryVariableCollectionsAsync()`?
   - Хардкод ключей в конфиге?
   - Поиск по имени в текущем документе?

2. **Как определить тип сниппета из HTML?**
   - Уже реализовано в `snippet-parser.ts` → поле `#SnippetType`
   - CSS-классы: `EProductSnippet2`, `EOfferItem`, `Organic_type_text`

3. **Как повторить вложенность HTML в Auto Layout?**
   - Рекурсивный обход DOM
   - Маппинг `<div>` → Frame с Auto Layout
   - Сохранение направления (row/column) из CSS flex

4. **Обработка вариантов компонентов:**
   - Desktop vs Touch (из `#Platform` или UA)
   - View variants (list/grid/compact)

---

## Файлы для изучения

- `src/utils/snippet-parser.ts` — парсинг HTML
- `src/plugin/data-assignment.ts` — маппинг данных на контейнеры
- `src/handlers/snippet-handlers.ts` — обработчики сниппетов
- `src/config.ts` — конфигурация, имена контейнеров

## Команды

```bash
npm run build  # сборка плагина
```

## Хард-ограничения

- ES5 target для code.js
- Никаких Node.js API в рантайме
- UI ↔ code.js только через postMessage
- Не ломать существующую функциональность импорта данных

---

**Первый шаг:** Исследовать Figma Plugin API для работы с библиотеками компонентов и создания инстансов программно. Начать с простого прототипа: создать один инстанс ESnippet и заполнить его данными.

